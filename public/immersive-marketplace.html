<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Gallery - Immersive Digital Art Marketplace</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gallery-container {
            width: 100%;
            height: 100%;
        }
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        #controls-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gallery-container"></div>
    <div id="info-panel"></div>
    <div id="controls-info">
        WASD: Move | Mouse: Look | Click: Select Artwork
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

    <script>
        const container = document.getElementById('gallery-container');
        const infoPanel = document.getElementById('info-panel');

        let scene, camera, renderer, controls;
        let artworks = [];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const wallGeometry = new THREE.PlaneGeometry(20, 4);

            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.z = -10;
            backWall.position.y = 2;
            scene.add(backWall);

            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.x = -10;
            leftWall.position.y = 2;
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.x = 10;
            rightWall.position.y = 2;
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);

            // Add artworks
            addArtworks();

            // Controls
            controls = new FirstPersonControls(camera, renderer.domElement);

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);

            animate();
        }

        function addArtworks() {
            const artworkPositions = [
                { x: -8, y: 1.5, z: -9.5 },
                { x: -4, y: 1.5, z: -9.5 },
                { x: 0, y: 1.5, z: -9.5 },
                { x: 4, y: 1.5, z: -9.5 },
                { x: 8, y: 1.5, z: -9.5 },
                { x: -9.5, y: 1.5, z: -8 },
                { x: -9.5, y: 1.5, z: -4 },
                { x: -9.5, y: 1.5, z: 0 },
                { x: -9.5, y: 1.5, z: 4 },
                { x: 9.5, y: 1.5, z: -8 },
                { x: 9.5, y: 1.5, z: -4 },
                { x: 9.5, y: 1.5, z: 0 },
                { x: 9.5, y: 1.5, z: 4 }
            ];

            artworkPositions.forEach((position, index) => {
                const artwork = createArtwork(`Artwork ${index + 1}`, position);
                artworks.push(artwork);
                scene.add(artwork);
            });
        }

        function createArtwork(title, position) {
            const frameGeometry = new THREE.BoxGeometry(2, 2, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);

            const canvasSize = 512;
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');

            // Create a gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
            gradient.addColorStop(0, `hsl(${Math.random() * 360}, 100%, 50%)`);
            gradient.addColorStop(1, `hsl(${Math.random() * 360}, 100%, 50%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // Add some random shapes
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.random() * canvasSize,
                    Math.random() * canvasSize,
                    Math.random() * 50 + 10,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 50%, 0.5)`;
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            const artworkMaterial = new THREE.MeshBasicMaterial({ map: texture });
            const artworkGeometry = new THREE.PlaneGeometry(1.8, 1.8);
            const artworkMesh = new THREE.Mesh(artworkGeometry, artworkMaterial);
            artworkMesh.position.z = 0.051;

            frame.add(artworkMesh);
            frame.position.set(position.x, position.y, position.z);

            // Rotate the artwork to face the center of the room
            frame.lookAt(0, frame.position.y, 0);

            frame.userData = { title: title, artist: "AI Artist", price: "$" + (Math.random() * 10000).toFixed(2) };

            return frame;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(artworks);

            if (intersects.length > 0) {
                const artwork = intersects[0].object;
                displayArtworkInfo(artwork.userData);
            } else {
                hideArtworkInfo();
            }
        }

        function displayArtworkInfo(info) {
            infoPanel.innerHTML = `
                <h3>${info.title}</h3>
                <p>Artist: ${info.artist}</p>
                <p>Price: ${info.price}</p>
            `;
            infoPanel.style.display = 'block';
        }

        function hideArtworkInfo() {
            infoPanel.style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        class FirstPersonControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();

                document.addEventListener('mousemove', this.onMouseMove.bind(this), false);
                document.addEventListener('keydown', this.onKeyDown.bind(this), false);
                document.addEventListener('keyup', this.onKeyUp.bind(this), false);
            }

            onMouseMove(event) {
                if (this.isLocked) {
                    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                    this.camera.rotation.y -= movementX * 0.002;
                    this.camera.rotation.x -= movementY * 0.002;
                    this.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rotation.x));
                }
            }

            onKeyDown(event) {
                switch (event.code) {
                    case 'KeyW': this.moveForward = true; break;
                    case 'KeyA': this.moveLeft = true; break;
                    case 'KeyS': this.moveBackward = true; break;
                    case 'KeyD': this.moveRight = true; break;
                }
            }

            onKeyUp(event) {
                switch (event.code) {
                    case 'KeyW': this.moveForward = false; break;
                    case 'KeyA': this.moveLeft = false; break;
                    case 'KeyS': this.moveBackward = false; break;
                    case 'KeyD': this.moveRight = false; break;
                }
            }

            update() {
                if (this.isLocked) {
                    this.velocity.x -= this.velocity.x * 10.0 * 0.016;
                    this.velocity.z -= this.velocity.z * 10.0 * 0.016;

                    this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
                    this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
                    this.direction.normalize();

                    if (this.moveForward || this.moveBackward) this.velocity.z -= this.direction.z * 400.0 * 0.016;
                    if (this.moveLeft || this.moveRight) this.velocity.x -= this.direction.x * 400.0 * 0.016;

                    this.camera.translateX(this.velocity.x * 0.016);
                    this.camera.translateZ(this.velocity.z * 0.016);
                }
            }

            lock() {
                this.domElement.requestPointerLock();
            }

            unlock() {
                document.exitPointerLock();
            }
        }

        init();

        // Lock controls on click
        document.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
            }
        });

        // Handle pointer lock state change
        document.addEventListener('pointerlockchange', () => {
            controls.isLocked = document.pointerLockElement === renderer.domElement;
        });
    </script>
</body>
</html>