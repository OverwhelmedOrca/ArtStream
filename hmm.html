<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Virtual Art Gallery</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    console.log("Initializing scene...");

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xF5F5F5);
    console.log("Scene created.");

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3);
    console.log("Camera created at position:", camera.position);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    console.log("Renderer created and added to DOM.");

    // Controls setup
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI / 2;
    console.log("OrbitControls initialized.");

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      console.log("Window resized, camera and renderer updated.");
    });

    // Remove unnecessary red sphere (if it exists)
    const redSphere = scene.getObjectByName('redSphere');
    if (redSphere) {
      scene.remove(redSphere);
      console.log("Red sphere removed from the scene.");
    }

    // Main hall
    const mainHallGeometry = new THREE.BoxGeometry(50, 6, 30);
    const mainHallMaterial = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
    const mainHall = new THREE.Mesh(mainHallGeometry, mainHallMaterial);
    mainHall.position.set(0, 3, 0); // Adjust position to align with ground
    scene.add(mainHall);
    console.log("Main hall created and added to scene.");

    // Smaller rooms
    const roomGeometry = new THREE.BoxGeometry(15, 6, 15);
    const roomMaterial = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
    const roomPositions = [
      [30, 3, 0],
      [-30, 3, 0],
      [0, 3, 20],
      [0, 3, -20],
      [0, 3, 40]
    ];
    for (let i = 0; i < 5; i++) {
      const room = new THREE.Mesh(roomGeometry, roomMaterial);
      room.position.set(...roomPositions[i]);
      scene.add(room);
      console.log(`Room ${i+1} created at position:`, room.position);
    }

    // Atrium
    const atriumGeometry = new THREE.BoxGeometry(20, 20, 20);
    const atriumMaterial = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
    const atrium = new THREE.Mesh(atriumGeometry, atriumMaterial);
    atrium.position.set(0, 10, 60); // Adjust position for correct placement
    scene.add(atrium);
    console.log("Atrium created and added to scene at position:", atrium.position);

    // Curved walkways
    const walkwayGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
    const walkwayMaterial = new THREE.MeshBasicMaterial({ color: 0xD2B48C });
    const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
    walkway.position.set(0, 0.25, 15); // Adjust position for correct placement
    walkway.rotation.x = Math.PI / 2;
    scene.add(walkway);
    console.log("Walkway created and added to scene.");

    // Accessibility ramps
    const rampGeometry = new THREE.PlaneGeometry(12, 1);
    const rampMaterial = new THREE.MeshBasicMaterial({ color: 0xD2B48C, side: THREE.DoubleSide });
    const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
    ramp.rotation.z = Math.atan(1 / 12);
    ramp.position.set(0, 0.5, -15); // Adjust position for correct placement
    scene.add(ramp);
    console.log("Ramp created and added to scene.");

    // Ambient lighting
    const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.5);
    scene.add(ambientLight);
    console.log("Ambient light added to scene.");

    // Spotlights
    for (let i = 0; i < 150; i++) {
      const spotlight = new THREE.SpotLight(0xFFFFFF, 1);
      spotlight.position.set(Math.random() * 50 - 25, 5, Math.random() * 30 - 15);
      spotlight.angle = Math.PI / 6;
      spotlight.penumbra = 0.5;
      spotlight.decay = 2;
      spotlight.distance = 50;
      spotlight.castShadow = true;
      scene.add(spotlight);
      console.log(`Spotlight ${i+1} created at position:`, spotlight.position);
    }

    // Dynamic lighting based on time of day
    function updateLighting(timeOfDay) {
      const dayTime = timeOfDay % 24;
      if (dayTime < 6 || dayTime > 18) {
        ambientLight.intensity = 0.2;
      } else {
        ambientLight.intensity = 0.8;
      }
      console.log("Lighting updated for time of day:", dayTime);
    }

    // Function to create an artwork display
    function createArtwork(imageUrl, position, scale) {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(imageUrl, (texture) => {
        const artworkGeometry = new THREE.PlaneGeometry(1, 1);
        const artworkMaterial = new THREE.MeshBasicMaterial({ map: texture });
        const artwork = new THREE.Mesh(artworkGeometry, artworkMaterial);
        artwork.position.copy(position);
        artwork.scale.copy(scale);
        scene.add(artwork);
        console.log("Artwork created and added to scene at position:", position);
      });
    }

    // Example artwork
    createArtwork('MonaLisa.jpg', new THREE.Vector3(0, 1.5, 0), new THREE.Vector3(3, 3, 1));

    // WASD controls
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'w':
          camera.position.z -= 0.1;
          break;
        case 's':
          camera.position.z += 0.1;
          break;
        case 'a':
          camera.position.x -= 0.1;
          break;
        case 'd':
          camera.position.x += 0.1;
          break;
      }
      console.log("Camera position updated:", camera.position);
    });

    // Interactive map
    const mapElement = document.createElement('div');
    mapElement.style.position = 'absolute';
    mapElement.style.top = '10px';
    mapElement.style.right = '10px';
    mapElement.style.width = '200px';
    mapElement.style.height = '200px';
    mapElement.style.background = 'rgba(255, 255, 255, 0.8)';
    document.body.appendChild(mapElement);
    console.log("Interactive map added to DOM.");

    // Level of Detail (LOD) for 3D models
    const lod = new THREE.LOD();
    const highDetail = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
    const lowDetail = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
    lod.addLevel(highDetail, 0);
    lod.addLevel(lowDetail, 100);
    scene.add(lod);
    console.log("LOD object created and added to scene.");

    // Occlusion culling
    const frustum = new THREE.Frustum();
    const cameraViewProjectionMatrix = new THREE.Matrix4();
    const visibleObjects = [];
    function updateVisibleObjects() {
      cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
      visibleObjects.length = 0;
      scene.traverse((object) => {
        if (object.isMesh && frustum.intersectsObject(object)) {
          visibleObjects.push(object);
        }
      });
      console.log("Visible objects updated:", visibleObjects.length);
    }

    // Texture streaming
    const textureLoader = new THREE.TextureLoader();
    const highResTexture = textureLoader.load('texture-close-up-wrinkled-surface.jpg');
    const lowResTexture = textureLoader.load('creative-background-with-cracked-paint-texture.jpg');
    const textureMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshBasicMaterial({ map: lowResTexture }));
    textureMesh.onBeforeRender = () => {
      if (camera.position.distanceTo(textureMesh.position) < 20) {
        textureMesh.material.map = highResTexture;
      } else {
        textureMesh.material.map = lowResTexture;
      }
      console.log("Texture streaming updated for mesh at position:", textureMesh.position);
    };
    scene.add(textureMesh);

    // Rendering loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      updateVisibleObjects();
      console.log("Scene rendered.");
    }

    animate();
  </script>
</body>
</html>
